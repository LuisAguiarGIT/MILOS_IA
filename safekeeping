# global array
# array = []
# global posicao
# posicao = 0


# def move_posicao(motor_esquerda, motor_direita, rotacoes, orientacao):
#     global xPos, yPos

#     move_frente(motor_esquerda, motor_direita, rotacoes)
#     atualiza_posicao(xPos, yPos, orientacao)


# def atualiza_posicao(posicao, orientacao):
#     if orientacao == "Norte":
#         return posicao + 6
#     elif orientacao == "Este":
#         return posicao + 1
#     elif orientacao == "Sul":
#         return posicao - 6
#     else:
#         return posicao - 1

# ============================ #
# Definicao da classe de robot #
# ============================ #

# class Robot:
#     def __init__(self, orientacao, posicao, ovelhas):
#     self.orientacao = orientacao  
#     self.posicao = posicao
#     self.ovelhas = ovelhas 

# def preenche_array(array):
#     for i in array:
#         array.append("#")
#     print(" | ")


# Array
# print(posicao)
# move_frente(MOTOR_ESQ, MOTOR_DIR, ROTACOES_CASA, orientacao_robot)
# print(posicao)



# Se estamos em alguma posição onde x = 0, quer dizer que só precisamos de verificar a célula acima (y+1) ou então a célula ao lado (x+1)
    if xPos == 0:
        # Procurar peças diretamente à frete do robot
        mv_dir.on_for_rotations(20, 20, rotacoes_casa)
        if deteta_parede(sensor_us):
            mv_dir.on_for_rotations(-20, -20, rotacoes_casa)
            # Iniciar ler a lista de peças
            # TODO
        else:
            # Voltar à posição inicial
            mv_dir.on_for_rotations(-20, -20, rotacoes_casa)
            # Indicar que a posição está vazia
            matriz[xPos+1][yPos] = "0"
        
        # Procurar peças à direita do robot
        vira_direita(motor_esquerda, motor_direita, rotacoes_virar, index)
        mv_dir.on_for_rotations(20, 20, rotacoes_casa)
        if deteta_parede(sensor_us):
            mv_dir.on_for_rotations(-20, -20, rotacoes_casa)
            # Inicia a leitura da lista de peças
            # TODO
        else:
            # Voltar à posição inicial
            mv_dir.on_for_rotations(-20, -20, rotacoes_casa)
            vira_esquerda(motor_esquerda, motor_direita, rotacoes_virar, index)
            # Indicar que a posição está vazia
            matriz[xPos][yPos+1] = "0"

    if xPos == 5:
        # Procurar peças diretamente à frente do robot
        mv_dir.on_for_rotations(20, 20, rotacoes_casa)
        if deteta_parede(sensor_us):
            mv_dir.on_for_rotations(-20, -20, rotacoes_casa)
            # Iniciar ler a lista de peças
            # TODO
        else:
            # Voltar à posição inicial
            mv_dir.on_for_rotations(-20, -20, rotacoes_casa)
            # Indicar que a posição está vazia
            matriz[xPos+1][yPos] = "0"
        
        # Procurar peças à direita do robot
        vira_esquerda(motor_esquerda, motor_direita, rotacoes_virar, index)
        mv_dir.on_for_rotations(20, 20, rotacoes_casa)
        if deteta_parede(sensor_us):
            mv_dir.on_for_rotations(-20, -20, rotacoes_casa)
            # Inicia a leitura da lista de peças
            # TODO
        else:
            # Voltar à posição inicial
            mv_dir.on_for_rotations(-20, -20, rotacoes_casa)
            vira_direita(motor_esquerda, motor_direita, rotacoes_virar, index)
            # Indicar que a posição está vazia
            matriz[xPos][yPos+1] = "0"

"program": "/home/robot/${workspaceRootFolderName}/main.py",